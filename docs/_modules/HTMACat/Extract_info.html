<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HTMACat.Extract_info &mdash; HTMACat-kit 1.0.2 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            HTMACat-kit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Get_start.html"><strong>Get_start</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Usage.html"><strong>Usage</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Examples.html"><strong>Examples</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HTMACat.html">HTMACat package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">HTMACat-kit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">HTMACat.Extract_info</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for HTMACat.Extract_info</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: UTF-8 -*-</span>
<span class="kn">from</span> <span class="nn">ase.io</span> <span class="kn">import</span> <span class="n">read</span>
<span class="kn">from</span> <span class="nn">catkit.gen.utils</span> <span class="kn">import</span> <span class="n">to_gratoms</span>
 
<span class="kn">import</span> <span class="nn">os</span>
<span class="c1">#from catkit.build import molecule</span>
<span class="kn">from</span> <span class="nn">ase.build</span> <span class="kn">import</span> <span class="n">molecule</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>


<span class="c1">### 1.Substract the reaction species</span>
<div class="viewcode-block" id="Extract_reaction"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.Extract_reaction">[docs]</a><span class="k">def</span> <span class="nf">Extract_reaction</span><span class="p">(</span><span class="n">Efile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract the adsorbate and gas species from a given reaction file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Efile : str</span>
<span class="sd">        Path of the reaction file.The reaction formula can be NH3(a)+O(a)=N(a)+NO(a)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple of two lists containing adsorbate and gas species, respectively.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ReaInfo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Efile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span>
    <span class="n">ad_species</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gas_species</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">specie_f_mol</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">specie_f_typ</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">specie_b_mol</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">specie_b_typ</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ReaInfo</span><span class="p">):</span>
        <span class="n">specie_f</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">specie_b</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="c1">### Operation on reactant</span>
        <span class="c1">##Extract the product molecule and type (a g s)</span>
        <span class="n">specie_f_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">specie_f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">))):</span>
            <span class="n">specie_f_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">specie_f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">specie</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specie_f_list</span><span class="p">):</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">specie</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">specie</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ad_species</span><span class="p">:</span>
                    <span class="n">ad_species</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mol</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gas_species</span><span class="p">:</span>
                    <span class="n">gas_species</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mol</span><span class="p">]</span>
            <span class="n">specie_f_mol</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mol</span><span class="p">]</span>
            <span class="n">specie_f_typ</span> <span class="o">+=</span> <span class="p">[</span><span class="n">typ</span><span class="p">]</span>
        <span class="c1">#print(ad_species)</span>
        <span class="c1">#print(gas_species)</span>

        <span class="c1">### Operation on product</span>
        <span class="c1">##Exstract the product molecule and type (a g s)</span>
        <span class="n">specie_b_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">specie_b</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">))):</span>
            <span class="n">specie_b_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">specie_b</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">specie</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specie_b_list</span><span class="p">):</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">specie</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">specie</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ad_species</span><span class="p">:</span>
                    <span class="n">ad_species</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mol</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gas_species</span><span class="p">:</span>
                    <span class="n">gas_species</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mol</span><span class="p">]</span>
            <span class="n">specie_b_mol</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mol</span><span class="p">]</span>
            <span class="n">specie_b_typ</span> <span class="o">+=</span> <span class="p">[</span><span class="n">typ</span><span class="p">]</span>
        <span class="c1">#print(ad_species)</span>
        <span class="c1">#print(gas_species)</span>

    <span class="n">ReaInfo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ad_species</span><span class="p">,</span> <span class="n">gas_species</span></div>


<span class="c1">#print(Extract_reaction())</span>


<span class="c1">### 2.Substract energy of adsoprtion configuration</span>
<div class="viewcode-block" id="Extract_energy"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.Extract_energy">[docs]</a><span class="k">def</span> <span class="nf">Extract_energy</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="n">struc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Batch extraction of calculated energy for specific species structure</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Efile : str</span>
<span class="sd">            Energy information file</span>
<span class="sd">        struc : list of str</span>
<span class="sd">            Specific species that want to extract energy</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            A tuple containing two lists:</span>

<span class="sd">            - Ener : list of float</span>
<span class="sd">                The list of extracted energies.</span>
<span class="sd">            - order : list of str</span>
<span class="sd">                The sequential list of the extracted energies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EnerInfo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Ener</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ads_ener</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EnerInfo</span><span class="p">):</span>
        <span class="n">ads</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ener</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">ads1</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ads</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">ads</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ads1</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">struc</span><span class="p">):</span>
            <span class="n">order</span> <span class="o">+=</span> <span class="p">[</span><span class="n">num</span><span class="p">]</span>
            <span class="n">Ener</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ener</span><span class="p">),</span> <span class="mi">3</span><span class="p">)]</span>
    <span class="n">EnerInfo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Ener</span><span class="p">,</span> <span class="n">order</span></div>


<span class="c1">#Dir = &quot;../Info/energy_list_coad.csv&quot;</span>
<span class="c1">#Ener,order=Extract_energy(Efile=Dir,struc=[&quot;NH3&quot;,&quot;OH&quot;])</span>
<span class="c1">#print(Ener,order)</span>


<span class="c1">### 3.Extract energy of radical &amp; slab</span>
<div class="viewcode-block" id="Extract_energy_single"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.Extract_energy_single">[docs]</a><span class="k">def</span> <span class="nf">Extract_energy_single</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="n">struc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract energy of radical &amp; slab.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Efile : str</span>
<span class="sd">        Energy information file.</span>
<span class="sd">    struc : str</span>
<span class="sd">        Structure that want to extract energy.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple containing the energy and the structure:</span>

<span class="sd">        - Ener : float</span>
<span class="sd">            The extracted energy.</span>
<span class="sd">        - struc : str</span>
<span class="sd">            The extracted structure.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EnerInfo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span>
    <span class="c1">#Ener=[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ads_ener</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EnerInfo</span><span class="p">):</span>
        <span class="n">ads</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ener</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="c1">#conf=ads.s[lit(&#39;_&#39;)[0:-2]</span>
        <span class="k">if</span> <span class="n">ads</span> <span class="o">==</span> <span class="n">struc</span><span class="p">:</span>
            <span class="c1">#Ener += [round(float(ener),2)]</span>
            <span class="n">Ener</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ener</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">EnerInfo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Ener</span><span class="p">,</span> <span class="n">struc</span></div>


<span class="c1">#Dir = &quot;../Info/energy_radical&quot;</span>
<span class="c1">#Ener,struc=Exstract_energy_single(Efile=Dir,struc=&quot;NH3&quot;)</span>
<span class="c1">#print(Ener,struc)</span>


<span class="c1">### 4.Extract adsorption energy</span>
<div class="viewcode-block" id="Extract_adsE"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.Extract_adsE">[docs]</a><span class="k">def</span> <span class="nf">Extract_adsE</span><span class="p">(</span><span class="n">slab_E</span><span class="p">,</span> <span class="n">radical_E</span><span class="p">,</span> <span class="n">tot_E</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the adsorption energy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    slab_E : float</span>
<span class="sd">        The crystal surface energy.</span>
<span class="sd">    radical_E : float</span>
<span class="sd">        The radical energy.</span>
<span class="sd">    tot_E : float</span>
<span class="sd">        The total energy.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The calculated adsorption energy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ads_E</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tot_E</span><span class="p">)</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">slab_E</span><span class="p">)</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">radical_E</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">ads_E</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span></div>


<span class="c1">### 5.Get the potcar file</span>
<div class="viewcode-block" id="get_potcar"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_potcar">[docs]</a><span class="k">def</span> <span class="nf">get_potcar</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;/data/jqyang/src/mypps/potpaw_PBE/&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the POTCAR file for VASP calculation.</span>

<span class="sd">      Parameters</span>
<span class="sd">      ----------</span>
<span class="sd">      poscar : str</span>
<span class="sd">          The file path of POSCAR.</span>
<span class="sd">      path : str, optional</span>
<span class="sd">          The path of the pseudopotential files, by default &#39;/data/jqyang/src/mypps/potpaw_PBE/&#39;.</span>

<span class="sd">      Returns</span>
<span class="sd">      -------</span>
<span class="sd">      None</span>
<span class="sd">          The function writes the combined POTCAR file.</span>

<span class="sd">      Raises</span>
<span class="sd">      ------</span>
<span class="sd">      ValueError</span>
<span class="sd">          If the elements in the structure files are different.</span>

<span class="sd">      &quot;&quot;&quot;</span>
    <span class="c1"># extract the element species:</span>
    <span class="n">list_elem</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">poscar</span><span class="p">):</span>
        <span class="n">struc</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">struc</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span>
        <span class="n">dic_sym</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
        <span class="n">list_elem</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dic_sym</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="c1"># if num of file, compare them</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">list_elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">list_elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">list_pot</span> <span class="o">=</span> <span class="n">list_elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Elements in structure files are different &amp;&amp; please correct! &quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_pot</span> <span class="o">=</span> <span class="n">list_elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># extract the potcars file and combines them</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;POTCAR&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm POTCAR&#39;</span><span class="p">)</span>
    <span class="n">potcar</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;POTCAR&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_pot</span><span class="p">)):</span>
        <span class="n">path_tmp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">list_pot</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;POTCAR&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">path_tmp</span><span class="p">):</span>
            <span class="n">potcar</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="n">potcar</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<span class="c1">### 6. Get the site info</span>
<span class="kn">from</span> <span class="nn">ase.neighborlist</span> <span class="kn">import</span> <span class="n">NeighborList</span>
<span class="kn">from</span> <span class="nn">ase.neighborlist</span> <span class="kn">import</span> <span class="n">natural_cutoffs</span>


<span class="c1">#from ase.build import molecule</span>
<div class="viewcode-block" id="get_site"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_site">[docs]</a><span class="k">def</span> <span class="nf">get_site</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">mole</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine the type of adsorption site.</span>

<span class="sd">       Parameters</span>
<span class="sd">       ----------</span>
<span class="sd">       poscar : str</span>
<span class="sd">           The name of the POSCAR file.</span>
<span class="sd">       mole : list</span>
<span class="sd">           A list consisting of the chemical formula of the adsorbed molecule</span>
<span class="sd">           and the atoms adsorbed on the point.</span>

<span class="sd">       Returns</span>
<span class="sd">       -------</span>
<span class="sd">       tuple</span>
<span class="sd">           A tuple of two lists: binding site types and the chemical symbols for</span>
<span class="sd">           other atoms bound to the binding site.</span>

<span class="sd">       &quot;&quot;&quot;</span>
    <span class="n">struc</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span>
    <span class="c1">### molecule and atom info</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">molecule</span><span class="p">(</span><span class="n">mole</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">atom_b</span> <span class="o">=</span> <span class="n">mole</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1">### POSACR structure analysis</span>
    <span class="c1">### neighbor list of every atoms</span>
    <span class="n">cutOff</span> <span class="o">=</span> <span class="n">natural_cutoffs</span><span class="p">(</span><span class="n">struc</span><span class="p">)</span>
    <span class="n">nl</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">(</span><span class="n">cutOff</span><span class="p">,</span> <span class="n">self_interaction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bothways</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nl</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">struc</span><span class="p">)</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">nl</span><span class="o">.</span><span class="n">get_connectivity_matrix</span><span class="p">()</span>
    <span class="c1">### list of every atoms : the atom order in poscar, number of binding atoms, the symbol of the atom</span>
    <span class="n">adatom_num</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">adatom_conn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">adatom_symb</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">struc</span><span class="o">.</span><span class="n">get_positions</span><span class="p">())):</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">nl</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1">#print(indices)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="c1">#print(&#39;atoms %s is adatom&#39;%(i))</span>
            <span class="n">adatom_num</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
            <span class="n">adatom_conn</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span>
            <span class="n">adatom_symb</span> <span class="o">+=</span> <span class="p">[</span><span class="n">struc</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()[</span><span class="n">i</span><span class="p">]]</span>
            <span class="c1">#for j, offset in zip(indices, offsets):</span>
            <span class="c1">#print(struc.positions[j] + offset @ struc.get_cell())</span>
    <span class="c1">### the dict: key= the atom order in poscar, the  number of binding atom</span>
    <span class="n">dic_adatom</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">adatom_num</span><span class="p">,</span> <span class="n">adatom_conn</span><span class="p">))</span>
    <span class="c1"># get connectivity of the atom we studied in adsorbed configuration</span>
    <span class="k">if</span> <span class="n">atom_b</span> <span class="ow">in</span> <span class="n">adatom_symb</span><span class="p">:</span>
        <span class="c1"># the atom order of the atom we studied</span>
        <span class="n">atom_b_num</span> <span class="o">=</span> <span class="n">struc</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom_b</span><span class="p">)</span>

    <span class="c1"># the binding number of the atom,list of binding atoms of the atom</span>
    <span class="c1"># corresponding chemical symbol atom in catalyst</span>
    <span class="n">atom_b_conn_a</span> <span class="o">=</span> <span class="n">dic_adatom</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">atom_b_num</span><span class="p">))</span>
    <span class="n">atom_b_conn</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">nl</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">atom_b_num</span><span class="p">)</span>
    <span class="n">atom_b_conn_symb</span> <span class="o">=</span> <span class="p">[</span><span class="n">struc</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atom_b_conn</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">36</span><span class="p">]</span>
    <span class="c1">#print(atom_b,atom_b_conn_a,atom_b_conn,atom_b_conn_symb)</span>

    <span class="c1">### adsorbed molecule analysis</span>
    <span class="n">cutOff_a</span> <span class="o">=</span> <span class="n">natural_cutoffs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">nl_a</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">(</span><span class="n">cutOff_a</span><span class="p">,</span> <span class="n">self_interaction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bothways</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nl_a</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">nl_a</span><span class="o">.</span><span class="n">get_connectivity_matrix</span><span class="p">()</span>
    <span class="n">mol_num</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mol_conn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mol_symb</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">())):</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">nl_a</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="c1">#atom number</span>
        <span class="n">mol_num</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span>
        <span class="c1">#atom connectivity</span>
        <span class="n">mol_conn</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span>
        <span class="c1">#atom symbol</span>
        <span class="n">mol_symb</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()[</span><span class="n">j</span><span class="p">]]</span>
    <span class="n">dic_mol</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">mol_num</span><span class="p">,</span> <span class="n">mol_conn</span><span class="p">))</span>
    <span class="c1"># get connectivity of atom in molecule</span>
    <span class="k">if</span> <span class="n">atom_b</span> <span class="ow">in</span> <span class="n">mol_symb</span><span class="p">:</span>
        <span class="n">atom_b_num</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atom_b</span><span class="p">)</span>
    <span class="n">atom_b_conn_m</span> <span class="o">=</span> <span class="n">dic_mol</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">atom_b_num</span><span class="p">))</span>

    <span class="c1">### calculate binding site type</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="s1">&#39;bri&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="s1">&#39;hol&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="s1">&#39;4-fold&#39;</span><span class="p">}</span>
    <span class="n">bind_type</span> <span class="o">=</span> <span class="n">typ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">atom_b_conn_a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">atom_b_conn_m</span><span class="p">)))</span>
    <span class="c1">#print(bind_type)</span>
    <span class="k">return</span> <span class="n">bind_type</span><span class="p">,</span> <span class="n">atom_b_conn_symb</span></div>


<span class="c1">### 7. To distinguish the surface and bulk atoms,atom binded with or not the surface</span>
<span class="kn">from</span> <span class="nn">catkit.gen.utils</span> <span class="kn">import</span> <span class="n">get_unique_coordinates</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<div class="viewcode-block" id="distinguish_atom_binding"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.distinguish_atom_binding">[docs]</a><span class="k">def</span> <span class="nf">distinguish_atom_binding</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">tol_layer</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">base_layer</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">atoms_layer</span><span class="o">=</span><span class="mi">9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Distinguishes different types of atoms in a surface structure and classifies them as adatoms, surface atoms,</span>
<span class="sd">        and subsurface atoms based on their Z coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poscar : str</span>
<span class="sd">            The input structure in POSCAR format</span>
<span class="sd">        tol_layer : float, optional</span>
<span class="sd">            Tolerance for distinguishing the Z coordinate of atoms belonging to different layers. Default is 0.01.</span>
<span class="sd">        tol : float, optional</span>
<span class="sd">            Tolerance for distinguishing the Z coordinate of adatoms and surface atoms. Default is 0.05.</span>
<span class="sd">        base_layer : int, optional</span>
<span class="sd">            The layer number where the surface atoms are located. Default is 4.</span>
<span class="sd">        atoms_layer : int, optional</span>
<span class="sd">            The minimum number of surface atoms required for the structure to be analyzed. Default is 9.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>
<span class="sd">            -adatoms : list</span>
<span class="sd">                A list of the indices of adatoms in the structure.</span>
<span class="sd">            -adatoms_symb : list</span>
<span class="sd">                A list of the chemical symbols of adatoms in the structure.</span>
<span class="sd">            -surfatoms : list</span>
<span class="sd">                A list of the indices of surface atoms in the structure.</span>
<span class="sd">            -surfatoms_symb : list</span>
<span class="sd">                A list of the chemical symbols of surface atoms in the structure.</span>
<span class="sd">            -subsurfatoms : list</span>
<span class="sd">                A list of the indices of subsurface atoms in the structure.</span>
<span class="sd">            -subsurfatoms_symb : list</span>
<span class="sd">                A list of the chemical symbols of subsurface atoms in the structure</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If tol is too large and not able to distinguish the layers, or if the structure cannot be analyzed.</span>

<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">poscar</span>
    <span class="c1">#the representative Z coords of every layer</span>
    <span class="n">coordinates_layer</span> <span class="o">=</span> <span class="n">get_unique_coordinates</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol_layer</span><span class="p">)</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c1">#the dict about the atoms and corresponding layers</span>
    <span class="n">key_atom</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">value_layer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#print(coordinates_layer)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">coord_layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinates_layer</span><span class="p">):</span>
            <span class="n">dis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coord</span> <span class="o">-</span> <span class="n">coord_layer</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dis</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="c1">#print(f&#39;atom {i+1} belongs to layer {j+1}&#39;)</span>
                <span class="n">key_atom</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">value_layer</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">base_layer</span><span class="p">:</span>
                <span class="c1">#print(f&#39;atom {i+1} belongs to layer {j+1}&#39;)</span>
                <span class="n">key_atom</span> <span class="o">+=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">value_layer</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1">#if len(key_atom) != (i+1):</span>
    <span class="c1">#   raise ValueError(&#39;tol is too large and not to distinguish the layers; Please reduce tol!&#39;)</span>
    <span class="n">dict_atom_layer</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">key_atom</span><span class="p">,</span> <span class="n">value_layer</span><span class="p">))</span>
    <span class="c1">#print(dict_atom_layer)</span>
    <span class="n">adatoms</span><span class="p">,</span> <span class="n">adatoms_symb</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">surfatoms</span><span class="p">,</span> <span class="n">surfatoms_symb</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">subsurfatoms</span><span class="p">,</span> <span class="n">subsurfatoms_symb</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)):</span>
        <span class="c1">#print(dict_atom_layer.get(k))</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">dict_atom_layer</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">base_layer</span><span class="p">:</span>
            <span class="n">dict_atom_layer</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;adatom&#39;</span>
            <span class="n">adatoms</span> <span class="o">+=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">adatoms_symb</span> <span class="o">+=</span> <span class="p">[</span><span class="n">struct</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()[</span><span class="n">k</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">dict_atom_layer</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="n">base_layer</span><span class="p">:</span>
            <span class="n">dict_atom_layer</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;surf_atom&#39;</span>
            <span class="n">surfatoms</span> <span class="o">+=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">surfatoms_symb</span> <span class="o">+=</span> <span class="p">[</span><span class="n">struct</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()[</span><span class="n">k</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">dict_atom_layer</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">base_layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">dict_atom_layer</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;subsurf_atom&#39;</span>
            <span class="n">subsurfatoms</span> <span class="o">+=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">subsurfatoms_symb</span> <span class="o">+=</span> <span class="p">[</span><span class="n">struct</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()[</span><span class="n">k</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>
    <span class="c1">#print(dict_atom_layer)</span>
    <span class="n">base_element</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Au&#39;</span><span class="p">,</span> <span class="s1">&#39;Ag&#39;</span><span class="p">,</span> <span class="s1">&#39;Pd&#39;</span><span class="p">,</span> <span class="s1">&#39;Pt&#39;</span><span class="p">,</span> <span class="s1">&#39;Rh&#39;</span><span class="p">,</span> <span class="s1">&#39;Ru&#39;</span><span class="p">,</span> <span class="s1">&#39;Ir&#39;</span><span class="p">,</span> <span class="s1">&#39;Cu&#39;</span><span class="p">,</span> <span class="s1">&#39;Fe&#39;</span><span class="p">,</span> <span class="s1">&#39;Co&#39;</span><span class="p">,</span> <span class="s1">&#39;Ni&#39;</span><span class="p">,</span> <span class="s1">&#39;Zn&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfatoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">atoms_layer</span><span class="p">):</span>
        <span class="c1">#print(&#39;surface atoms &gt;9&#39;)</span>
        <span class="c1">#print(surfatoms_symb)</span>
        <span class="n">surfatoms_final</span><span class="p">,</span> <span class="n">surfatoms_symb_final</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">atom_symb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surfatoms_symb</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">atom_symb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base_element</span><span class="p">:</span>
                <span class="c1">#print(atom_symb)</span>
                <span class="n">adatoms</span> <span class="o">+=</span> <span class="p">[</span><span class="n">surfatoms</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span>
                <span class="n">adatoms_symb</span> <span class="o">+=</span> <span class="p">[</span><span class="n">atom_symb</span><span class="p">]</span>
                <span class="c1">#surfatoms.pop(n)</span>
                <span class="c1">#surfatoms_symb.pop(n)</span>
                <span class="n">tmp</span> <span class="o">+=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">atom_symb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surfatoms_symb</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
                <span class="n">surfatoms_final</span> <span class="o">+=</span> <span class="p">[</span><span class="n">surfatoms</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span>
                <span class="n">surfatoms_symb_final</span> <span class="o">+=</span> <span class="p">[</span><span class="n">surfatoms_symb</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span>
        <span class="n">surfatoms</span> <span class="o">=</span> <span class="n">surfatoms_final</span>
        <span class="n">surfatoms_symb</span> <span class="o">=</span> <span class="n">surfatoms_symb_final</span>
        <span class="c1">#print(surfatoms_symb)</span>
        <span class="c1">### Ignore structures where Z coord of adatoms &lt; Z coord of surfatoms</span>
        <span class="n">Z_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">surfatoms</span><span class="p">])</span>
        <span class="n">Z_adatom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">adatoms</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">Z_adatom</span> <span class="o">&lt;=</span> <span class="n">Z_mean</span><span class="p">:</span>
            <span class="n">surfatoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">surfatoms_symb</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">### Ignore the structures without standard and integrated surface configurations</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfatoms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="n">atoms_layer</span><span class="p">):</span>
        <span class="c1">#raise ValueError(f&#39;{poscar} can not been analyzed!&#39;)</span>
        <span class="n">surfatoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">surfatoms_symb</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#return adatoms,adatoms_symb,surfatoms,surfatoms_symb,subsurfatoms,subsurfatoms_symb</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    #extract the atoms and corresponding chemical symbols of specific layer</span>
<span class="sd">    layer_atoms=[]</span>
<span class="sd">    layer_atoms_symb=[] </span>
<span class="sd">    for m in range(len(coordinates)):</span>
<span class="sd">        if dict_atom_layer.get(m) == layer:           </span>
<span class="sd">           layer_atoms += [m]</span>
<span class="sd">           layer_atoms_symb += [struct.get_chemical_symbols()[m]]</span>
<span class="sd">    return layer_atoms,layer_atoms_symb</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="n">adatoms</span><span class="p">,</span> <span class="n">adatoms_symb</span><span class="p">,</span> <span class="n">surfatoms</span><span class="p">,</span> <span class="n">surfatoms_symb</span><span class="p">,</span> <span class="n">subsurfatoms</span><span class="p">,</span> <span class="n">subsurfatoms_symb</span></div>


<span class="c1">### get the neighboring atoms fo specific adatoms</span>
<div class="viewcode-block" id="get_atom_neigh"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_atom_neigh">[docs]</a><span class="k">def</span> <span class="nf">get_atom_neigh</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the neighboring atoms of specific adsorbed atoms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poscar : str or pymatgen.Structure</span>
<span class="sd">        The VASP file or pymatgen.Structure object containing the lattice structure information.</span>
<span class="sd">    atom : str</span>
<span class="sd">        The chemical symbol of the specific adsorbed atom.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[list,list]</span>
<span class="sd">        A tuple of two lists:</span>

<span class="sd">        - The indices of the nearest neighbor atoms of the specified atom in the lattice structure.</span>
<span class="sd">        - The chemical element symbols of the nearest neighbor atoms.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">poscar</span>
    <span class="n">adatoms</span><span class="p">,</span> <span class="n">adatoms_symb</span><span class="p">,</span> <span class="n">surfatoms</span><span class="p">,</span> <span class="n">surfatoms_symb</span><span class="p">,</span> <span class="n">subsurfatoms</span><span class="p">,</span> <span class="n">subsurfatoms_symb</span> <span class="o">=</span> <span class="n">distinguish_atom_binding</span><span class="p">(</span>
        <span class="n">poscar</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">)</span>
    <span class="n">struct_symb</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">symbols</span>
    <span class="n">atom_symb</span> <span class="o">=</span> <span class="n">chemical_symbols</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span>

    <span class="n">atom_index</span><span class="p">,</span> <span class="n">atom_neighs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="c1"># whether input atom occur in the bulk</span>
    <span class="k">if</span> <span class="n">atom_symb</span> <span class="ow">in</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">():</span>
        <span class="n">cutOff</span> <span class="o">=</span> <span class="n">natural_cutoffs</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">(</span><span class="n">cutOff</span><span class="p">,</span> <span class="n">self_interaction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bothways</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nl</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>
        <span class="c1"># whether input atom occur in the adatoms</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">adatom_symb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adatoms_symb</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">atom_symb</span> <span class="o">==</span> <span class="n">adatom_symb</span><span class="p">:</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">nl</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">adatoms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">atom_index</span> <span class="o">+=</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>
                    <span class="n">atom_neighs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">struct</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()[</span><span class="n">index</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No </span><span class="si">{</span><span class="n">atom_symb</span><span class="si">}</span><span class="s1"> adatom&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No </span><span class="si">{</span><span class="n">atom_symb</span><span class="si">}</span><span class="s1"> in </span><span class="si">{</span><span class="n">struct_symb</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">atom_index</span><span class="p">,</span> <span class="n">atom_neighs</span></div>


<span class="c1">### 8. TO get atoms binding with surface among adatoms</span>
<div class="viewcode-block" id="get_binding_adatom"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_binding_adatom">[docs]</a><span class="k">def</span> <span class="nf">get_binding_adatom</span><span class="p">(</span><span class="n">poscar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the adsorbed atoms and the surface atoms to which they bind.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        poscar : str</span>
<span class="sd">            The VASP file path or pymatgen.Structure object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[list,list,list,list,list,list]</span>
<span class="sd">            A tuple containing the following elements:</span>

<span class="sd">            - bind_adatoms :list</span>
<span class="sd">                The list of indices of adsorbed atoms that are bound to surface atoms.</span>
<span class="sd">            - bind_adatoms_symb :list</span>
<span class="sd">                The list of chemical symbols of adsorbed atoms that are bound to surface atoms.</span>
<span class="sd">            - adspecie :list</span>
<span class="sd">                The list of chemical representations of adsorbates.</span>
<span class="sd">            - bind_type_symb :list</span>
<span class="sd">                The list of adsorption types.</span>
<span class="sd">            - bind_surfatoms :list</span>
<span class="sd">                The list of indices of surface atoms that are bound to adsorbed atoms.</span>
<span class="sd">            - bind_surfatoms_symb :list</span>
<span class="sd">                The list of chemical symbols of surface atoms that are bound to adsorbed atoms.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function extracts adsorbed and surface atoms from the structure, calculates the neighbor list,</span>
<span class="sd">        and determines which adsorbed atoms are bound to which surface atoms. It then extracts the adsorbate species,</span>
<span class="sd">        the adsorption type, and the surface atoms that are bound to each adsorbed atom.</span>

<span class="sd">        &quot;&quot;&quot;</span>
    <span class="c1"># extract surface atoms and adsorbed atoms</span>
    <span class="c1">#adatoms,adatoms_symb=distinguish_atom_binding(poscar,tol=0.05,layer=&#39;adatom&#39;)</span>
    <span class="c1">#surf_atoms,surf_atom_symb=distinguish_atom_binding(poscar,tol=0.05,layer=&#39;surf_atom&#39;)</span>

    <span class="c1"># neighbor list of atoms in struct</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">poscar</span>
    <span class="n">adatoms</span><span class="p">,</span> <span class="n">adatoms_symb</span><span class="p">,</span> <span class="n">surfatoms</span><span class="p">,</span> <span class="n">surfatoms_symb</span><span class="p">,</span> <span class="n">subsurfatoms</span><span class="p">,</span> <span class="n">subsurfatoms_symb</span> <span class="o">=</span> <span class="n">distinguish_atom_binding</span><span class="p">(</span>
        <span class="n">poscar</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="c1">#print(adatoms_symb,surfatoms_symb)</span>
    <span class="c1">#print(struct.symbols)</span>
    <span class="n">cutOff</span> <span class="o">=</span> <span class="n">natural_cutoffs</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">mult</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="c1">#print(cutOff)</span>
    <span class="n">nl</span> <span class="o">=</span> <span class="n">NeighborList</span><span class="p">(</span><span class="n">cutOff</span><span class="p">,</span> <span class="n">self_interaction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bothways</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">nl</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>
    <span class="c1">#### extract the adatoms binded with surface and corresponding surface atoms</span>
    <span class="n">bind_adatoms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bind_adatoms_symb</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bind_surfatoms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bind_surfatoms_symb</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">site_type</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">site_type2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">site_type_symb</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">### Extract the binded surface atoms and binded adsorbed atoms</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adatoms</span><span class="p">):</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">nl</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tmp2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#print(indices)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="c1">#print(index)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">surfatoms</span><span class="p">:</span>
                <span class="n">bind_adatoms</span> <span class="o">+=</span> <span class="p">[</span><span class="n">atom</span><span class="p">]</span>
                <span class="n">tmp</span> <span class="o">+=</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">tmp2</span> <span class="o">+=</span> <span class="p">[</span><span class="n">struct</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()[</span><span class="n">index</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="c1">#tmp3_symb=[struct.get_chemical_symbols()[i] for i in tmp3]</span>
        <span class="k">if</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">bind_surfatoms</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tmp</span><span class="p">]</span>
            <span class="n">bind_surfatoms_symb</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tmp2</span><span class="p">]</span>
            <span class="n">site_type</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)]</span>
        <span class="c1">#print(struct.get_scaled_positions()[atom][0:-1])</span>
    <span class="n">bind_adatoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bind_adatoms</span><span class="p">))</span>
    <span class="n">bind_adatoms_symb</span> <span class="o">=</span> <span class="p">[</span><span class="n">struct</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bind_adatoms</span><span class="p">]</span>
    <span class="c1">### Extract the bind type</span>
    <span class="n">item</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bind_type_symb</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">adatom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bind_adatoms</span><span class="p">):</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">adatom</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">item_tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">subsurfatoms</span><span class="p">):</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">atom</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.025</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.025</span><span class="p">:</span>
                <span class="n">item_tmp</span> <span class="o">+=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">item_tmp</span> <span class="o">+=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">item_tmp</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
    <span class="c1">#print(item)</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;bri&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39;hol&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;4-fold&#39;</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">bind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">site_type</span><span class="p">):</span>
        <span class="n">bind_type</span> <span class="o">=</span> <span class="n">typ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bind</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bind_type</span> <span class="o">==</span> <span class="s1">&#39;hol&#39;</span> <span class="ow">and</span> <span class="n">item</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bind_type_symb</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;fcc&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">bind_type</span> <span class="o">==</span> <span class="s1">&#39;hol&#39;</span> <span class="ow">and</span> <span class="n">item</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bind_type_symb</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;hcp&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bind_type_symb</span> <span class="o">+=</span> <span class="p">[</span><span class="n">bind_type</span><span class="p">]</span>

    <span class="c1">### Extract the adsorbed species</span>
    <span class="n">adspecie</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bind_adatoms</span><span class="p">):</span>
        <span class="n">indices</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">nl</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="n">tmp3</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="p">]</span>
        <span class="c1">#print(indices)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="ow">in</span> <span class="n">surfatoms</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">index</span> <span class="ow">in</span> <span class="n">subsurfatoms</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp3</span> <span class="o">+=</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="c1">#print(tmp3)</span>
        <span class="n">tmp3_symb</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">([</span><span class="n">struct</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tmp3</span><span class="p">]))</span>
        <span class="n">Ele</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">tmp3_symb</span><span class="p">))</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">Num</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">tmp3_symb</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="c1">#print(tmp3_symb)</span>
        <span class="c1">#print(Ele)</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">E</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Ele</span><span class="p">):</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span> <span class="o">+</span> <span class="n">E</span>
            <span class="k">if</span> <span class="n">Num</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">Num</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">mol</span> <span class="o">==</span> <span class="s1">&#39;*OH2&#39;</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="s1">&#39;*H2O&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">adspecie</span> <span class="o">+=</span> <span class="p">[</span><span class="n">mol</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1">#adspecie+=[&#39;&#39;.join(list(chain.from_iterable(zip(Ele,Num))))]</span>
        <span class="c1">#mol=molecule(tmp3_symb)[0]</span>
        <span class="c1">#print(mol.symbol)</span>
    <span class="k">return</span> <span class="n">bind_adatoms</span><span class="p">,</span> <span class="n">bind_adatoms_symb</span><span class="p">,</span> <span class="n">adspecie</span><span class="p">,</span> <span class="n">bind_type_symb</span><span class="p">,</span> <span class="n">bind_surfatoms</span><span class="p">,</span> <span class="n">bind_surfatoms_symb</span></div>


<span class="c1">### 9. To get the distance between adatoms</span>
<span class="kn">from</span> <span class="nn">ase.geometry</span> <span class="kn">import</span> <span class="n">get_distances</span>
<span class="kn">from</span> <span class="nn">catkit.gen</span> <span class="kn">import</span> <span class="n">defaults</span>


<div class="viewcode-block" id="get_distance_adatoms"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_distance_adatoms">[docs]</a><span class="k">def</span> <span class="nf">get_distance_adatoms</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the distance between adsorbed atoms in a VASP file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poscar : str</span>
<span class="sd">        The VASP file or structure object.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        A parameter that determines whether atoms are bonded. The default value is 0.1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[list,list]</span>
<span class="sd">        A tuple containing two lists:</span>

<span class="sd">            - dis_symb_matrix : list of str</span>
<span class="sd">                A list of strings indicating the atomic symbols of the adsorbed atoms and their corresponding distance.</span>
<span class="sd">            - dis_matrix : list of float</span>
<span class="sd">                A list of distances between adsorbed atoms.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If there is only one atom in the VASP file.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">poscar</span>
    <span class="c1">#struct=read(poscar,format=&#39;vasp&#39;)</span>
    <span class="n">bind_adatoms</span><span class="p">,</span> <span class="n">bind_adatoms_symb</span><span class="p">,</span> <span class="n">adspecie</span><span class="p">,</span> <span class="n">bind_type_symb</span><span class="p">,</span> <span class="n">bind_surfatoms</span><span class="p">,</span> <span class="n">bind_surfatoms_symb</span> <span class="o">=</span> <span class="n">get_binding_adatom</span><span class="p">(</span>
        <span class="n">poscar</span><span class="p">)</span>
    <span class="n">radii</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radii&#39;</span><span class="p">)</span>
    <span class="n">radii_adatom</span> <span class="o">=</span> <span class="p">[</span><span class="n">radii</span><span class="p">[</span><span class="n">struct</span><span class="o">.</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bind_adatoms</span><span class="p">]</span>
    <span class="n">dis_matrix</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># distcance</span>
    <span class="n">dis_symb_matrix</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># symbol corresponding distance</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bind_adatoms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only 1 atom and No distance&#39;</span><span class="p">)</span>
    <span class="c1">## distance when there are 2 adatoms</span>
    <span class="c1">#elif len(bind_adatoms) == 2:</span>
    <span class="c1">#bond_distance=sum(radii_adatom)</span>
    <span class="c1">#print(bond_distance)</span>
    <span class="c1">#dis = get_distances(struct.get_positions()[bind_adatoms[0]],struct.get_positions()[bind_adatoms[1]])[1][0][0]</span>
    <span class="c1">#print(dis)</span>
    <span class="c1">#if abs(dis-bond_distance) &lt; tol:</span>
    <span class="c1">#   print(&#39;The dis may below the possible bond length&#39;)</span>
    <span class="c1">#else:</span>
    <span class="c1">#print(round(dis,3))</span>
    <span class="c1">#return round(dis,3)</span>
    <span class="c1">## distance when there are above 2 adatoms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bind_adatoms</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bind_adatoms</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dis_symb</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">bind_adatoms_symb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bind_adatoms_symb</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
                <span class="n">bond_distance</span> <span class="o">=</span> <span class="n">radii_adatom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">radii_adatom</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="c1">## get minmum distance of adsorbed atoms</span>
                <span class="n">p_all</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()</span>
                <span class="n">p1_scaled</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">bind_adatoms</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">p2_scaled</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">bind_adatoms</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="c1"># replace the minus coord</span>
                <span class="n">struct</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">p_all</span><span class="p">)</span>
                <span class="c1">#print(p1_scaled[0],p2_scaled[0])</span>
                <span class="k">if</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.50</span><span class="p">:</span>
                    <span class="n">p_all</span><span class="p">[</span><span class="n">bind_adatoms</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">struct</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">p_all</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">0.50</span><span class="p">:</span>
                    <span class="n">p_all</span><span class="p">[</span><span class="n">bind_adatoms</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">struct</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">p_all</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.50</span><span class="p">:</span>
                    <span class="n">p_all</span><span class="p">[</span><span class="n">bind_adatoms</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">struct</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">p_all</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">0.50</span><span class="p">:</span>
                    <span class="n">p_all</span><span class="p">[</span><span class="n">bind_adatoms</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">struct</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">p_all</span><span class="p">)</span>
                <span class="n">dis</span> <span class="o">=</span> <span class="n">get_distances</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="n">bind_adatoms</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                                    <span class="n">struct</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="n">bind_adatoms</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">#print(struct.get_positions()[bind_adatoms[i]],struct.get_positions()[bind_adatoms[i+1]])</span>
                <span class="c1">#print(get_distances(struct.get_positions()[bind_adatoms[i]],struct.get_positions()[bind_adatoms[i+1]]))</span>

                <span class="c1">## ignore the configuraton with too near distance</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dis</span> <span class="o">-</span> <span class="n">bond_distance</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The dis may below the possible bond length&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dis_symb_matrix</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dis_symb</span><span class="p">]</span>
                    <span class="n">dis_matrix</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">dis_symb_matrix</span><span class="p">,</span> <span class="n">dis_matrix</span></div>


<span class="c1">### 10. To get the minimum distance between two group</span>
<span class="kn">from</span> <span class="nn">ase.geometry</span> <span class="kn">import</span> <span class="n">get_distances</span>


<div class="viewcode-block" id="get_min_distance_group"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_min_distance_group">[docs]</a><span class="k">def</span> <span class="nf">get_min_distance_group</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">group1</span><span class="p">,</span> <span class="n">group2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Compute the minimum distance between two sets of atoms in a crystal structure.</span>

<span class="sd">      Parameters</span>
<span class="sd">      ----------</span>
<span class="sd">      struct : ase.Atoms</span>
<span class="sd">          The crystal structure.</span>
<span class="sd">      group1 : list of int</span>
<span class="sd">          Indices of the atoms in the first group.</span>
<span class="sd">      group2 : list of int</span>
<span class="sd">          Indices of the atoms in the second group.</span>

<span class="sd">      Returns</span>
<span class="sd">      -------</span>
<span class="sd">      numpy.ndarray</span>
<span class="sd">          A 2D array containing the distances between each pair of atoms in group1 and group2.</span>
<span class="sd">      &quot;&quot;&quot;</span>
    <span class="n">p1_scaled</span> <span class="o">=</span> <span class="p">[</span><span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group1</span><span class="p">]</span>
    <span class="n">p2_scaled</span> <span class="o">=</span> <span class="p">[</span><span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group2</span><span class="p">]</span>
    <span class="n">dis_matrix</span> <span class="o">=</span> <span class="n">get_distances</span><span class="p">(</span><span class="n">p1_scaled</span><span class="p">,</span> <span class="n">p2_scaled</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dis_matrix</span></div>


<span class="c1">### 11. To peprocess the raw info for descritor construction</span>

<div class="viewcode-block" id="Construct_descriptor_info"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.Construct_descriptor_info">[docs]</a><span class="k">def</span> <span class="nf">Construct_descriptor_info</span><span class="p">(</span><span class="n">raw_file</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">feature</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Construct descriptor information from raw data file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raw_file : str</span>
<span class="sd">        Path to the raw data file.</span>
<span class="sd">    atoms : list</span>
<span class="sd">        a list of atoms.</span>
<span class="sd">    feature : list</span>
<span class="sd">        a list of features.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    feature_value : list</span>
<span class="sd">        a list of feature values for each atom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">comp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">raw_file</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span>
    <span class="n">index_line</span><span class="p">,</span> <span class="n">index_row</span><span class="p">,</span> <span class="n">matrix_info</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">com</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comp</span><span class="p">):</span>
        <span class="n">line_tmp</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">line_tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ltmp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line_tmp</span><span class="p">):</span>
                <span class="n">tmp1</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ltmp</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
                <span class="n">tmp2</span> <span class="o">+=</span> <span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">index_row</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_line</span> <span class="o">+=</span> <span class="p">[</span><span class="n">line_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">matrix_info</span> <span class="o">+=</span> <span class="p">[</span><span class="n">line_tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
    <span class="n">comp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">feature_value</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">index_line</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ele</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">des</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">index_row</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">des</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">matrix_info</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="n">row</span><span class="p">])]</span>
        <span class="n">feature_value</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tmp</span><span class="p">]</span>
    <span class="c1">#return index_line,index_row,matrix_info,feature_value</span>
    <span class="k">return</span> <span class="n">feature_value</span></div>


<span class="c1">### 12. Extrate the based info:atomic_numbers, atomic_names, atomic_masses, covalent_radii</span>
<span class="kn">from</span> <span class="nn">ase.data</span> <span class="kn">import</span> <span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">atomic_names</span><span class="p">,</span> <span class="n">atomic_masses</span><span class="p">,</span> <span class="n">covalent_radii</span><span class="p">,</span> <span class="n">vdw_radii</span>


<div class="viewcode-block" id="Extract_atomic_info"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.Extract_atomic_info">[docs]</a><span class="k">def</span> <span class="nf">Extract_atomic_info</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts information related to the provided atoms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    atoms : list of int</span>
<span class="sd">        List of integers representing the atomic numbers of the atoms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[list,list,list,list]</span>
<span class="sd">        A tuple containing the following information:</span>

<span class="sd">        - names_atoms : list of str</span>
<span class="sd">            List of strings representing the names of the atoms.</span>
<span class="sd">        - radii_atoms : list of float</span>
<span class="sd">            List of floats representing the covalent radii of the atoms.</span>
<span class="sd">        - mass_atoms : list of float</span>
<span class="sd">            List of floats representing the atomic masses of the atoms.</span>
<span class="sd">        - vdw_radii_atoms : list of float</span>
<span class="sd">            List of floats representing the van der Waals radii of the atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numbers_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atomic_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]</span>
    <span class="n">names_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atomic_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numbers_atoms</span><span class="p">]</span>
    <span class="n">radii_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">covalent_radii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numbers_atoms</span><span class="p">]</span>
    <span class="n">mass_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atomic_masses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numbers_atoms</span><span class="p">]</span>
    <span class="n">vdw_radii_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">vdw_radii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numbers_atoms</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">names_atoms</span><span class="p">,</span> <span class="n">radii_atoms</span><span class="p">,</span> <span class="n">mass_atoms</span><span class="p">,</span> <span class="n">vdw_radii_atoms</span></div>


<span class="c1">### 13. Extract the stable adsorption type for single molecule or radical adsorption based on adsorption energy</span>
<div class="viewcode-block" id="get_site_stable"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_site_stable">[docs]</a><span class="k">def</span> <span class="nf">get_site_stable</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="n">Ecut</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts the stable adsorption type for single molecule or radical adsorption based on adsorption energy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Efile : str</span>
<span class="sd">        Path to the file containing adsorption energies.</span>
<span class="sd">    Ecut : float, optional</span>
<span class="sd">        The maximum energy cut-off for stable adsorption (default is -0.1).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[dict,dict,list,dict]</span>
<span class="sd">        - spec_ads: a dictionary with species as keys and a list of possible adsorption types as values.</span>
<span class="sd">        - spec_ads_stable: a dictionary with species as keys and the stable adsorption type as values.</span>
<span class="sd">        - dir_list_final: a list of directories containing the stable adsorption configurations.</span>
<span class="sd">        - spec_ads_stable_surfa: a dictionary with species as keys and the symbol of the surface atom bound to the adsorbate in the stable adsorption configuration as values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EnerInfo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span>
    <span class="n">species_ads</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bri&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;fcc&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;hcp&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;4-fold&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ads_ener</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EnerInfo</span><span class="p">):</span>
        <span class="n">species_ads</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">specie_ads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">species_ads</span><span class="p">)</span>
    <span class="n">EnerInfo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">spec</span><span class="p">,</span> <span class="n">ads_type</span><span class="p">,</span> <span class="n">ads_type_stable</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">dir_list_final</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ads_type_surfa</span><span class="p">,</span> <span class="n">ads_type_stable_surfa</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="n">specie_ads</span><span class="p">:</span>
        <span class="n">ads_type_tmp</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">dir_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="c1">#ads_type_surfa_tmp=[]</span>
        <span class="n">spec</span> <span class="o">+=</span> <span class="p">[</span><span class="n">specie</span><span class="p">]</span>
        <span class="n">EnerInfo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ads_ener</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EnerInfo</span><span class="p">):</span>
            <span class="n">ads</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ads1</span> <span class="o">=</span> <span class="n">ads</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">ener</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="c1">#print(ads1,specie,ads1==specie)</span>
            <span class="k">if</span> <span class="n">ads1</span> <span class="o">==</span> <span class="n">specie</span> <span class="ow">and</span> <span class="nb">float</span><span class="p">(</span><span class="n">ener</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ecut</span><span class="p">):</span>
                <span class="n">bind_adatoms</span><span class="p">,</span> <span class="n">bind_adatoms_symb</span><span class="p">,</span> <span class="n">adspecie</span><span class="p">,</span> <span class="n">bind_type_symb</span><span class="p">,</span> <span class="n">bind_surfatoms</span><span class="p">,</span> <span class="n">bind_surfatoms_symb</span> <span class="o">=</span> <span class="n">get_binding_adatom</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ads</span><span class="si">}</span><span class="s1">/CONTCAR&#39;</span><span class="p">)</span>
                <span class="c1">#bind_adatoms,bind_adatoms_symb,adspecie,bind_type_symb,bind_surfatoms,bind_surfatoms_symb=get_binding_adatom(f&#39;{ads}/optmk/CONTCAR&#39;)</span>
                <span class="c1">#print(bind_adatoms,bind_adatoms_symb,adspecie,bind_type_symb,bind_surfatoms,bind_surfatoms_symb)</span>
                <span class="k">if</span> <span class="n">bind_type_symb</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="n">bind_type_symb</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span>
                <span class="n">ads_type_tmp</span> <span class="o">+=</span> <span class="p">[</span><span class="n">typ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bind_type_symb</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="n">energy</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ener</span><span class="p">]</span>
                <span class="n">dir_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">ads_type_surfa</span> <span class="o">+=</span> <span class="p">[</span><span class="n">bind_surfatoms_symb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">EnerInfo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">ads_type</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ads_type_tmp</span><span class="p">))]</span>
        <span class="n">ads_type_stable</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">ads_type_tmp</span><span class="p">[</span><span class="n">energy</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">energy</span><span class="p">))]]]</span>
        <span class="n">dir_list_final</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dir_list</span><span class="p">[</span><span class="n">energy</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">energy</span><span class="p">))]]</span>
        <span class="n">ads_type_stable_surfa</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ads_type_surfa</span><span class="p">[</span><span class="n">energy</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">energy</span><span class="p">))]]</span>
    <span class="n">spec_ads</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">ads_type</span><span class="p">))</span>
    <span class="n">spec_ads_stable</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">ads_type_stable</span><span class="p">))</span>
    <span class="n">spec_ads_stable_surfa</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">ads_type_stable_surfa</span><span class="p">))</span>
    <span class="c1">#print(ads_type_stable_surfa)</span>
    <span class="k">return</span> <span class="n">spec_ads</span><span class="p">,</span> <span class="n">spec_ads_stable</span><span class="p">,</span> <span class="n">dir_list_final</span><span class="p">,</span> <span class="n">spec_ads_stable_surfa</span></div>


<span class="c1">###13-2. Extract the stable adsorption type for single molecule or radical adsorption based on the calculated energy</span>
<div class="viewcode-block" id="get_site_stable_energy"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_site_stable_energy">[docs]</a><span class="k">def</span> <span class="nf">get_site_stable_energy</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="n">Ecut</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract the stable adsorption type for single molecule or radical adsorption based on the calculated energy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Efile : str</span>
<span class="sd">        The path to the file containing the adsorption energy information.</span>
<span class="sd">    Ecut : float, optional</span>
<span class="sd">        The cutoff energy for considering stable adsorption types. Default is 0.0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[dict,dict,list]</span>
<span class="sd">        The first dictionary contains all the possible adsorption types for each species.</span>
<span class="sd">        The second dictionary contains the stable adsorption type for each species.</span>
<span class="sd">        The third list contains the corresponding directories for each species&#39; stable adsorption type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EnerInfo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span>
    <span class="n">species_ads</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bri&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;fcc&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;hcp&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;4-fold&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ads_ener</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EnerInfo</span><span class="p">):</span>
        <span class="n">species_ads</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">specie_ads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">species_ads</span><span class="p">)</span>
    <span class="n">EnerInfo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">spec</span><span class="p">,</span> <span class="n">ads_type</span><span class="p">,</span> <span class="n">ads_type_stable</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">dir_list_final</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="n">specie_ads</span><span class="p">:</span>
        <span class="n">ads_type_tmp</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">dir_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">spec</span> <span class="o">+=</span> <span class="p">[</span><span class="n">specie</span><span class="p">]</span>
        <span class="n">EnerInfo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ads_ener</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EnerInfo</span><span class="p">):</span>
            <span class="n">ads</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ads1</span> <span class="o">=</span> <span class="n">ads</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">ener</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="c1">#print(ads1,specie,ads1==specie)</span>
            <span class="k">if</span> <span class="n">ads1</span> <span class="o">==</span> <span class="n">specie</span> <span class="ow">and</span> <span class="nb">float</span><span class="p">(</span><span class="n">ener</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ecut</span><span class="p">):</span>
                <span class="n">bind_adatoms</span><span class="p">,</span> <span class="n">bind_adatoms_symb</span><span class="p">,</span> <span class="n">adspecie</span><span class="p">,</span> <span class="n">bind_type_symb</span><span class="p">,</span> <span class="n">bind_surfatoms</span><span class="p">,</span> <span class="n">bind_surfatoms_symb</span> <span class="o">=</span> <span class="n">get_binding_adatom</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ads</span><span class="si">}</span><span class="s1">/CONTCAR&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">bind_type_symb</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="n">bind_type_symb</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span>
                <span class="n">ads_type_tmp</span> <span class="o">+=</span> <span class="p">[</span><span class="n">typ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bind_type_symb</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="n">energy</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ener</span><span class="p">]</span>
                <span class="n">dir_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">EnerInfo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">ads_type</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ads_type_tmp</span><span class="p">))]</span>
        <span class="n">ads_type_stable</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">ads_type_tmp</span><span class="p">[</span><span class="n">energy</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">energy</span><span class="p">))]]]</span>
        <span class="n">dir_list_final</span> <span class="o">+=</span> <span class="p">[</span><span class="n">dir_list</span><span class="p">[</span><span class="n">energy</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">energy</span><span class="p">))]]</span>
    <span class="n">spec_ads</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">ads_type</span><span class="p">))</span>
    <span class="n">spec_ads_stable</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">ads_type_stable</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">spec_ads</span><span class="p">,</span> <span class="n">spec_ads_stable</span><span class="p">,</span> <span class="n">dir_list_final</span></div>


<span class="c1">### get the energy of  most stable configurationi for single radical</span>
<div class="viewcode-block" id="get_adsorption_energy_stable"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_adsorption_energy_stable">[docs]</a><span class="k">def</span> <span class="nf">get_adsorption_energy_stable</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="n">specie</span><span class="p">,</span> <span class="n">dop_typ</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;get the energy of  most stable configurationi for single radical</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Efile : str</span>
<span class="sd">        The name of the file storing energy information.</span>
<span class="sd">    specie : str</span>
<span class="sd">        The name of the adsorbed species.</span>
<span class="sd">    dop_typ : str</span>
<span class="sd">        The type of doping.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[list,list]</span>
<span class="sd">        A tuple containing the name of the most stable radical and its energy.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EnerInfo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">Efile</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span>
    <span class="n">dir_spe</span><span class="p">,</span> <span class="n">dir_ene</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ads_ener</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EnerInfo</span><span class="p">):</span>
        <span class="n">ads</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ads1</span> <span class="o">=</span> <span class="n">ads</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">dop</span> <span class="o">=</span> <span class="n">ads</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">ener</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="c1">#if (ads1 == specie) &amp; (dop in dop_typ):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ads1</span> <span class="o">==</span> <span class="n">specie</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dop</span> <span class="o">==</span> <span class="n">dop_typ</span><span class="p">):</span>
            <span class="n">dir_spe</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ads</span><span class="p">]</span>
            <span class="n">dir_ene</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">ener</span><span class="p">)]</span>
    <span class="n">EnerInfo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dir_ene</span><span class="p">:</span>
        <span class="n">spe</span> <span class="o">=</span> <span class="n">dir_spe</span><span class="p">[</span><span class="n">dir_ene</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dir_ene</span><span class="p">))]</span>
        <span class="n">ene</span> <span class="o">=</span> <span class="n">dir_ene</span><span class="p">[</span><span class="n">dir_ene</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dir_ene</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">spe</span><span class="p">,</span> <span class="n">ene</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">specie</span><span class="p">,</span> <span class="kc">None</span></div>


<span class="c1">### get the file name of reaction dir</span>
<div class="viewcode-block" id="get_file_name"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_file_name">[docs]</a><span class="k">def</span> <span class="nf">get_file_name</span><span class="p">(</span><span class="n">reaction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a chemical reaction as a string in the form of &#39;reactants = products&#39;,</span>
<span class="sd">    constructs the file name for the corresponding reaction file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reaction : str</span>
<span class="sd">        A chemical reaction in the form of &#39;reactants = products&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The file name for the corresponding reaction file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; get_file_name(&#39;H2(g) + Cl2(g) = 2HCl(g)&#39;)</span>
<span class="sd">    &#39;H2+Cl2=2HCl&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">specie_f</span> <span class="o">=</span> <span class="n">reaction</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">specie_b</span> <span class="o">=</span> <span class="n">reaction</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1">### Construct the reaction name</span>
    <span class="c1">##1.Extract the reactant molecule and type (a g s)</span>
    <span class="n">specie_f_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">specie_f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">))):</span>
        <span class="n">specie_f_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">specie_f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
    <span class="n">specie_f_mol</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">specie_f_typ</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">specie</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specie_f_list</span><span class="p">):</span>
        <span class="n">specie_f_mol</span> <span class="o">+=</span> <span class="p">[</span><span class="n">specie</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
        <span class="n">specie_f_typ</span> <span class="o">+=</span> <span class="p">[</span><span class="n">specie</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
    <span class="c1">##2.Extract the product molecule and type (a g s)</span>
    <span class="n">specie_b_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">specie_b</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">))):</span>
        <span class="n">specie_b_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">specie_b</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
    <span class="n">specie_b_mol</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">specie_b_typ</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">specie</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">specie_b_list</span><span class="p">):</span>
        <span class="n">specie_b_mol</span> <span class="o">+=</span> <span class="p">[</span><span class="n">specie</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
        <span class="n">specie_b_typ</span> <span class="o">+=</span> <span class="n">specie</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1">##3.construct the file name for every reaction</span>
    <span class="n">File</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">specie_f_mol</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="s1">&#39;+&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">specie_b_mol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">File</span></div>


<span class="c1">### calculate the energy of radicals</span>
<div class="viewcode-block" id="cal_Erad"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.cal_Erad">[docs]</a><span class="k">def</span> <span class="nf">cal_Erad</span><span class="p">(</span><span class="n">FErad</span><span class="p">,</span> <span class="n">Radical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     Calculates the energy of a given radical.</span>

<span class="sd">     Parameters</span>
<span class="sd">     ----------</span>
<span class="sd">     FErad : str</span>
<span class="sd">         The name of the file containing the radical energies.</span>
<span class="sd">     Radical : str</span>
<span class="sd">         The name of the radical to calculate the energy for.</span>

<span class="sd">     Returns</span>
<span class="sd">     -------</span>
<span class="sd">     float</span>
<span class="sd">         The energy of the given radical.</span>

<span class="sd">     Notes</span>
<span class="sd">     -----</span>
<span class="sd">     The file containing the radical energies should be a comma-separated file,Just like this:Pt_100_CO2_0,-226.43504734</span>
<span class="sd">     &quot;&quot;&quot;</span>
    <span class="n">Erad</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">FErad</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">Eradicals</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">Eradical</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Eradicals</span><span class="p">):</span>
            <span class="n">radical</span> <span class="o">=</span> <span class="n">Eradical</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">Eradical</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="c1"># find the atom energy</span>
            <span class="k">if</span> <span class="n">Radical</span> <span class="o">==</span> <span class="n">radical</span><span class="p">:</span>
                <span class="c1">#print(i,radical)</span>
                <span class="n">Erad</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Erad</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Erad</span></div>


<span class="c1">## calculate the energy of radical relative to atom energy: ExCyHzO=xEC+yEH+zEO</span>
<div class="viewcode-block" id="cal_Erad_atom"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.cal_Erad_atom">[docs]</a><span class="k">def</span> <span class="nf">cal_Erad_atom</span><span class="p">(</span><span class="n">FErad</span><span class="p">,</span> <span class="n">Radical</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the energy of each atom in a given radical.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    FErad : str</span>
<span class="sd">        The name of the file containing the atom energies.</span>
<span class="sd">    Radical : str</span>
<span class="sd">        The name of the radical to calculate the atom energies for.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The total energy of all atoms in the given radical.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Erad</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rad</span> <span class="o">=</span> <span class="n">molecule</span><span class="p">(</span><span class="n">Radical</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rad</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">():</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">FErad</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">Eradicals</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">Eradical</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Eradicals</span><span class="p">):</span>
                <span class="n">radical</span> <span class="o">=</span> <span class="n">Eradical</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">Eradical</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="c1"># find the atom energy</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">radical</span><span class="p">:</span>
                    <span class="c1">#print(i,radical)</span>
                    <span class="n">Erad</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Erad</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Erad</span></div>


<div class="viewcode-block" id="cal_Eslab"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.cal_Eslab">[docs]</a><span class="k">def</span> <span class="nf">cal_Eslab</span><span class="p">(</span><span class="n">FEslab</span><span class="p">,</span> <span class="n">facet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the energy of a given slab facet.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    FEslab : str</span>
<span class="sd">        File path to the file containing the slab energies.</span>
<span class="sd">    facet : list</span>
<span class="sd">        a List containing the Miller indices of the facet.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Energy of the given slab facet.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; cal_Eslab(&#39;path/to/file.csv&#39;, [1, 0, 0])</span>
<span class="sd">    -123.45</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">E_slab</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">FEslab</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">Eslabs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">Eslab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Eslabs</span><span class="p">):</span>
            <span class="n">slab</span> <span class="o">=</span> <span class="n">Eslab</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">Eslab</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># find the facet energy</span>
            <span class="k">if</span> <span class="n">facet</span> <span class="o">==</span> <span class="n">slab</span><span class="p">:</span>
                <span class="c1">#print(slab)</span>
                <span class="n">E_slab</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">E_slab</span></div>


<span class="c1">## calculate the adE with  atom energy: E(xCyHzO)ad=ECHOsurf-Esurf-xEC-yEH-zEO</span>
<div class="viewcode-block" id="cal_Eads"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.cal_Eads">[docs]</a><span class="k">def</span> <span class="nf">cal_Eads</span><span class="p">(</span><span class="n">Flist</span><span class="p">,</span> <span class="n">FErad</span><span class="p">,</span> <span class="n">FEslab</span><span class="p">,</span> <span class="n">radicals</span><span class="p">,</span> <span class="n">Erad_property</span><span class="o">=</span><span class="s1">&#39;radical&#39;</span><span class="p">,</span> <span class="n">Facet_property</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the adsorption energy based on atom energy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Flist : str</span>
<span class="sd">        The filename of the file that contains the list of adsorption energy configurations.</span>
<span class="sd">    FErad : str</span>
<span class="sd">        The filename of the file that contains the atom energies of the radicals.</span>
<span class="sd">    FEslab : str</span>
<span class="sd">        The filename of the file that contains the energies of the slabs.</span>
<span class="sd">    radicals : list</span>
<span class="sd">        The list of radicals to consider.</span>
<span class="sd">    Erad_property : str, optional</span>
<span class="sd">        The property of the radical energy calculation. Default is &#39;radical&#39;.</span>
<span class="sd">    Facet_property : str, optional</span>
<span class="sd">        The property of the facet energy calculation. Default is &#39;all&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    Outputs</span>
<span class="sd">    -------</span>
<span class="sd">    adsE_{Erad_property}_{Facet_property} : file</span>
<span class="sd">    The file that contains the calculated adsorption energies.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EnerInfo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">Flist</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span>
    <span class="n">Foutput</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;adsE_</span><span class="si">{</span><span class="n">Erad_property</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">Facet_property</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span>
    <span class="c1">#num=0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ads_ener</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EnerInfo</span><span class="p">):</span>
        <span class="c1"># extract the facet and radical</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">conf_facet</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">conf_radical</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># extract the energy of adsorption configuration</span>
        <span class="n">Eads</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="c1">#print(conf)</span>
        <span class="k">if</span> <span class="n">Eads</span><span class="p">:</span>
            <span class="n">E_rad</span><span class="p">,</span> <span class="n">E_slab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">conf_radical</span> <span class="ow">in</span> <span class="n">radicals</span><span class="p">:</span>
                <span class="c1">#if conf.split(&#39;_&#39;)[-3] == &#39;b1&#39;:</span>
                <span class="c1">#   num=num+1</span>
                <span class="c1">#else:</span>
                <span class="c1">#   num=num</span>
                <span class="c1">## extract the energy of radical based atom energy</span>
                <span class="k">if</span> <span class="n">Erad_property</span> <span class="o">==</span> <span class="s1">&#39;atom&#39;</span><span class="p">:</span>
                    <span class="n">E_rad</span> <span class="o">=</span> <span class="n">cal_Erad_atom</span><span class="p">(</span><span class="n">FErad</span><span class="p">,</span> <span class="n">conf_radical</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">Erad_property</span> <span class="o">==</span> <span class="s1">&#39;radical&#39;</span><span class="p">:</span>
                    <span class="n">E_rad</span> <span class="o">=</span> <span class="n">cal_Erad</span><span class="p">(</span><span class="n">FErad</span><span class="p">,</span> <span class="n">conf_radical</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Erad has not the property!&#39;</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="c1">##  extract the energy of facet</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">FEslab</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">Eslabs</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">Eslab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Eslabs</span><span class="p">):</span>
                        <span class="n">line1</span> <span class="o">=</span> <span class="n">Eslab</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">Ftmp</span> <span class="o">=</span> <span class="n">line1</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                        <span class="n">conf_slab</span> <span class="o">=</span> <span class="n">Ftmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">line2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">eval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Eslab</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;]&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>
                        <span class="c1">#print(Ftmp[2])</span>
                        <span class="c1">#print(Ftmp[2]== &#39;True&#39;)</span>
                        <span class="k">if</span> <span class="n">conf_slab</span> <span class="o">==</span> <span class="n">conf_facet</span><span class="p">:</span>
                            <span class="n">poscar</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;./poscar/</span><span class="si">{</span><span class="n">conf</span><span class="si">}</span><span class="s1">.vasp&#39;</span>
                            <span class="n">adatoms</span><span class="p">,</span> <span class="n">adatoms_symb</span><span class="p">,</span> <span class="n">surfatoms</span><span class="p">,</span> <span class="n">surfatoms_symb</span><span class="p">,</span> <span class="n">subsurfatoms</span><span class="p">,</span> <span class="n">subsurfatoms_symb</span> <span class="o">=</span> <span class="n">distinguish_atom_binding</span><span class="p">(</span>
                                <span class="n">poscar</span><span class="p">,</span>
                                <span class="n">tol</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                                <span class="n">base_layer</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Ftmp</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                                <span class="n">atoms_layer</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">Ftmp</span><span class="p">[</span><span class="mi">4</span><span class="p">])))</span>
                            <span class="k">if</span> <span class="n">line2</span> <span class="o">==</span> <span class="n">surfatoms_symb</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">Facet_property</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                                    <span class="n">E_slab</span> <span class="o">=</span> <span class="n">Ftmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="k">elif</span> <span class="p">(</span><span class="n">Facet_property</span> <span class="o">==</span> <span class="s1">&#39;stable&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Ftmp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">):</span>
                                    <span class="n">E_slab</span> <span class="o">=</span> <span class="n">Ftmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">continue</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">continue</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">E_slab</span><span class="p">:</span>
                <span class="n">Eads</span> <span class="o">=</span> <span class="n">Extract_adsE</span><span class="p">(</span><span class="n">slab_E</span><span class="o">=</span><span class="n">E_slab</span><span class="p">,</span> <span class="n">radical_E</span><span class="o">=</span><span class="n">E_rad</span><span class="p">,</span> <span class="n">tot_E</span><span class="o">=</span><span class="n">Eads</span><span class="p">)</span>
                <span class="c1">#print(conf,Eads)</span>
                <span class="n">Foutput</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">conf</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">Eads</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;NO Eslab&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">conf</span><span class="si">}</span><span class="s1"> is not calculated!&#39;</span><span class="p">)</span>
    <span class="c1">#print(f&#39;Species: {num}&#39;)</span>
    <span class="n">EnerInfo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">Foutput</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="cal_adE_coad"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.cal_adE_coad">[docs]</a><span class="k">def</span> <span class="nf">cal_adE_coad</span><span class="p">(</span><span class="n">Flist</span><span class="p">,</span> <span class="n">FErad</span><span class="p">,</span> <span class="n">FEslab</span><span class="p">,</span> <span class="n">Erad_property</span><span class="o">=</span><span class="s1">&#39;radical&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the adsorption energy of CO on a surface with multiple radicals</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Flist: str</span>
<span class="sd">        File path of a text file that contains the adsorption energy information of the system in each line.</span>
<span class="sd">        Each line should be in the following format: facet_radical1_radical2, adsorption_energy, where</span>
<span class="sd">        facet_radical1_radical2 is the identifier of the system, and adsorption_energy is the corresponding</span>
<span class="sd">        adsorption energy.</span>
<span class="sd">    FErad: str</span>
<span class="sd">        File path of a text file that contains the energy of each radical. Each line should be in the following</span>
<span class="sd">        format: radical, energy, where radical is the identifier of the radical, and energy is the corresponding</span>
<span class="sd">        energy.</span>
<span class="sd">    FEslab: str</span>
<span class="sd">        File path of a text file that contains the energy of each slab..</span>
<span class="sd">    Erad_property: str, optional</span>
<span class="sd">        The property used to calculate the radical energy. It can be either &#39;atom&#39; or &#39;radical&#39;. Default is &#39;radical&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    The function writes the calculated adsorption energy for each system to a file named &#39;adsE_coad_&lt;Erad_property&gt;&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EnerInfo</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">Flist</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span>
    <span class="n">Foutput</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;adsE_coad_</span><span class="si">{</span><span class="n">Erad_property</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ads_ener</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">EnerInfo</span><span class="p">):</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Eads</span> <span class="o">=</span> <span class="n">ads_ener</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">conf_facet</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">conf_radicals</span> <span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1">#if Eads and len(conf.split(&#39;_&#39;)) &gt; 4:</span>
        <span class="c1">#if Eads and len(conf.split(&#39;_&#39;)) &gt; 3:</span>
        <span class="k">if</span> <span class="n">Eads</span><span class="p">:</span>
            <span class="c1">#print(Eads,len(conf.split(&#39;_&#39;)))</span>
            <span class="n">E_rad</span><span class="p">,</span> <span class="n">E_slab</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">E_slab</span> <span class="o">=</span> <span class="n">cal_Eslab</span><span class="p">(</span><span class="n">FEslab</span><span class="p">,</span> <span class="n">conf_facet</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Erad_property</span> <span class="o">==</span> <span class="s1">&#39;atom&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">conf_radical</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conf_radicals</span><span class="p">):</span>
                    <span class="c1">## extract the energy of radical based atom energy</span>
                    <span class="n">E_rad</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">E_rad</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">cal_Erad_atom</span><span class="p">(</span><span class="n">FErad</span><span class="p">,</span> <span class="n">conf_radical</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">Erad_property</span> <span class="o">==</span> <span class="s1">&#39;radical&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">conf_radical</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">conf_radicals</span><span class="p">):</span>
                    <span class="n">E_rad</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">E_rad</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">cal_Erad</span><span class="p">(</span><span class="n">FErad</span><span class="p">,</span> <span class="n">conf_radical</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Erad has not the property!&#39;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="n">Eads</span> <span class="o">=</span> <span class="n">Extract_adsE</span><span class="p">(</span><span class="n">slab_E</span><span class="o">=</span><span class="n">E_slab</span><span class="p">,</span> <span class="n">radical_E</span><span class="o">=</span><span class="n">E_rad</span><span class="p">,</span> <span class="n">tot_E</span><span class="o">=</span><span class="n">Eads</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">Eads</span><span class="p">)</span>
            <span class="n">Foutput</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">conf</span><span class="si">}</span><span class="s1">,</span><span class="si">{</span><span class="n">Eads</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">conf</span><span class="si">}</span><span class="s1"> is not calculated!&#39;</span><span class="p">)</span>
    <span class="n">EnerInfo</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">Foutput</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<span class="c1">### TO extract the struct info and energy of specific slab and</span>
<div class="viewcode-block" id="Extract_slab_info_1"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.Extract_slab_info_1">[docs]</a><span class="k">def</span> <span class="nf">Extract_slab_info_1</span><span class="p">(</span><span class="n">Flist</span><span class="p">,</span> <span class="n">facet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts structural information and energy of specific slab.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Flist : str</span>
<span class="sd">        File path to the list of slab energies.</span>
<span class="sd">    facet : list</span>
<span class="sd">        List of strings representing the surface facets to extract information for.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[list,list,list,list,list]</span>
<span class="sd">        - E_slab : list</span>
<span class="sd">            a List of energies for the given facets.</span>
<span class="sd">        - surf : list</span>
<span class="sd">            a List of lists of atomic symbols for the surface atoms of the given facets.</span>
<span class="sd">        - E_stable : list</span>
<span class="sd">            a List of the most stable energy value among the given facets.</span>
<span class="sd">        - surf_stable : list</span>
<span class="sd">            a List of atomic symbols for the surface atoms of the most stable facet.</span>
<span class="sd">        - layer_info : list</span>
<span class="sd">            a List containing the number of layers and the number of atoms in each layer of the most stable facet.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function extracts the energy and structural information of a specific slab given a list of energies and the</span>
<span class="sd">    surface facets to extract information for. The energy and surface information are extracted for all slabs that match</span>
<span class="sd">    the given facet. If there is only one matching slab, the energy and surface information are returned directly. If</span>
<span class="sd">    there are multiple matching slabs, the function determines the most stable facet by finding the slab with the lowest</span>
<span class="sd">    energy, and returns the energy and surface information for that slab.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">E_slab</span><span class="p">,</span> <span class="n">surf</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">Flist</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">Eslabs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">Eslab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Eslabs</span><span class="p">):</span>
            <span class="n">conf</span> <span class="o">=</span> <span class="n">Eslab</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">slab</span> <span class="o">=</span> <span class="n">Eslab</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">Eslab</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">## TO extract the energy and surface info</span>
            <span class="k">if</span> <span class="n">facet</span> <span class="o">==</span> <span class="n">slab</span><span class="p">:</span>
                <span class="n">E_slab</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">E</span><span class="p">)]</span>
                <span class="c1"># TO extract struct info: layers and atom numbers of layer</span>
                <span class="n">poscar</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;./poscar/</span><span class="si">{</span><span class="n">conf</span><span class="si">}</span><span class="s1">.vasp&#39;</span>
                <span class="n">struct</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span>
                <span class="n">layer</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">get_unique_coordinates</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">))</span>
                <span class="n">atoms_layer</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()))</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
                <span class="n">adatoms</span><span class="p">,</span> <span class="n">adatoms_symb</span><span class="p">,</span> <span class="n">surfatoms</span><span class="p">,</span> <span class="n">surfatoms_symb</span><span class="p">,</span> <span class="n">subsurfatoms</span><span class="p">,</span> <span class="n">subsurfatoms_symb</span> <span class="o">=</span> <span class="n">distinguish_atom_binding</span><span class="p">(</span>
                    <span class="n">poscar</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">base_layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span> <span class="n">atoms_layer</span><span class="o">=</span><span class="n">atoms_layer</span><span class="p">)</span>
                <span class="n">surf</span> <span class="o">+=</span> <span class="p">[</span><span class="n">surfatoms_symb</span><span class="p">]</span>
    <span class="c1">## TO find out the most stable facet</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">E_slab</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">E_slab</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">E_stable</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">E_slab</span><span class="p">)</span>
        <span class="n">surf_stable</span> <span class="o">=</span> <span class="n">surf</span><span class="p">[</span><span class="n">E_slab</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">E_stable</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">E_slab</span><span class="p">,</span> <span class="n">surf</span><span class="p">,</span> <span class="p">[</span><span class="n">E_stable</span><span class="p">],</span> <span class="p">[</span><span class="n">surf_stable</span><span class="p">],</span> <span class="p">[</span><span class="n">layer</span><span class="p">,</span> <span class="n">atoms_layer</span><span class="p">]</span></div>


<span class="c1">###TO Extract the struct info and energy of slabs</span>
<div class="viewcode-block" id="Extract_slab_info_2"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.Extract_slab_info_2">[docs]</a><span class="k">def</span> <span class="nf">Extract_slab_info_2</span><span class="p">(</span><span class="n">Flist</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;TO Extract the struct info and energy of slabs</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Flist: str</span>
<span class="sd">        Crystal surface energy information file</span>
<span class="sd">    layer: int</span>
<span class="sd">        Number of crystal layers, default value is 4</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Fslab</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;energy_facet_f&#39;</span><span class="p">,</span> <span class="s1">&#39;w+&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">Flist</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">Eslabs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">Eslab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Eslabs</span><span class="p">):</span>
            <span class="n">conf</span> <span class="o">=</span> <span class="n">Eslab</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#TO extract energy</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">Eslab</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">E_slab</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
            <span class="c1"># TO extract struct info: layers and atom numbers of layer</span>
            <span class="n">poscar</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;./poscar/</span><span class="si">{</span><span class="n">conf</span><span class="si">}</span><span class="s1">.vasp&#39;</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">get_unique_coordinates</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">))</span>
            <span class="n">atoms_layer</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">()))</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
            <span class="n">adatoms</span><span class="p">,</span> <span class="n">adatoms_symb</span><span class="p">,</span> <span class="n">surfatoms</span><span class="p">,</span> <span class="n">surfatoms_symb</span><span class="p">,</span> <span class="n">subsurfatoms</span><span class="p">,</span> <span class="n">subsurfatoms_symb</span> <span class="o">=</span> <span class="n">distinguish_atom_binding</span><span class="p">(</span>
                <span class="n">poscar</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">base_layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span> <span class="n">atoms_layer</span><span class="o">=</span><span class="n">atoms_layer</span><span class="p">)</span>
            <span class="n">surf</span> <span class="o">=</span> <span class="n">surfatoms_symb</span>

            <span class="n">Fslab</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">conf</span><span class="si">}</span><span class="s1">,</span><span class="se">\t</span><span class="si">{</span><span class="n">E_slab</span><span class="si">}</span><span class="s1">,</span><span class="se">\t</span><span class="si">{</span><span class="n">surf</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">Fslab</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<span class="c1">###To identify whether the symmetry is keeped###</span>
<div class="viewcode-block" id="get_symmetry_surfatoms"><a class="viewcode-back" href="../../HTMACat.html#HTMACat.Extract_info.get_symmetry_surfatoms">[docs]</a><span class="k">def</span> <span class="nf">get_symmetry_surfatoms</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether surface atoms are reconstructed</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    poscar : str or Structure</span>
<span class="sd">        Vasp format structure file</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance for determining whether surface atoms are reconstructed. The default is 0.3.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        A sign of whether surface atoms are reconstructed. &quot;When surface atoms are reconstructed,</span>
<span class="sd">        &#39;NO&#39; is returned, otherwise &#39;YES&#39; is returned.&quot;.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">poscar</span>
    <span class="c1">#struct=read(poscar,format=&#39;vasp&#39;)</span>
    <span class="n">adatoms</span><span class="p">,</span> <span class="n">adatoms_symb</span><span class="p">,</span> <span class="n">surfatoms</span><span class="p">,</span> <span class="n">surfatoms_symb</span><span class="p">,</span> <span class="n">subsurfatoms</span><span class="p">,</span> <span class="n">subsurfatoms_symb</span> <span class="o">=</span> <span class="n">distinguish_atom_binding</span><span class="p">(</span>
        <span class="n">poscar</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="c1">#print(surfatoms)</span>

    <span class="n">dis_matrix</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># distcance</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">surfatoms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1">#raise ValueError(&#39;Only or less than 1 atom and No distance&#39;)</span>
        <span class="n">symmetry_prop</span> <span class="o">=</span> <span class="s1">&#39;NO&#39;</span>
        <span class="k">return</span> <span class="n">symmetry_prop</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># p_all=struct.get_scaled_positions()</span>
        <span class="c1"># struct.set_scaled_positions(p_all)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surfatoms</span><span class="p">):</span>
            <span class="n">dis</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1">#print(atom1)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">surfatoms</span><span class="p">):</span>
                <span class="c1">#print(atom2)</span>
                <span class="k">if</span> <span class="n">atom1</span> <span class="o">==</span> <span class="n">atom2</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">struct</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;vasp&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">struct</span> <span class="o">=</span> <span class="n">poscar</span>
                    <span class="n">p_all</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()</span>
                    <span class="n">struct</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">p_all</span><span class="p">)</span>

                    <span class="n">p1_scaled</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">surfatoms</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">p2_scaled</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">()[</span><span class="n">surfatoms</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.50</span><span class="p">:</span>
                        <span class="n">p_all</span><span class="p">[</span><span class="n">surfatoms</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">struct</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">p_all</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">0.50</span><span class="p">:</span>
                        <span class="n">p_all</span><span class="p">[</span><span class="n">surfatoms</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">struct</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">p_all</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mf">0.50</span><span class="p">:</span>
                        <span class="n">p_all</span><span class="p">[</span><span class="n">surfatoms</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">struct</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">p_all</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p2_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="mf">0.50</span><span class="p">:</span>
                        <span class="n">p_all</span><span class="p">[</span><span class="n">surfatoms</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p1_scaled</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">struct</span><span class="o">.</span><span class="n">set_scaled_positions</span><span class="p">(</span><span class="n">p_all</span><span class="p">)</span>
                    <span class="n">dis</span> <span class="o">+=</span> <span class="p">[</span>
                        <span class="n">get_distances</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="n">surfatoms</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
                                      <span class="n">struct</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="n">surfatoms</span><span class="p">[</span><span class="n">j</span><span class="p">]])[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">]</span>
            <span class="c1">#print(dis)</span>
            <span class="n">dis_matrix</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">dis</span><span class="p">)]</span>
        <span class="c1">#print(min(dis_matrix),max(dis_matrix),np.mean(dis_matrix))</span>
        <span class="c1">#if max(dis_matrix)-min(dis_matrix) &gt; tol:</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dis_matrix</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">dis_matrix</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">symmetry_prop</span> <span class="o">=</span> <span class="s1">&#39;NO&#39;</span>
            <span class="k">return</span> <span class="n">symmetry_prop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symmetry_prop</span> <span class="o">=</span> <span class="s1">&#39;YES&#39;</span>
        <span class="k">return</span> <span class="n">symmetry_prop</span></div>


<span class="kn">from</span> <span class="nn">catkit.gen</span> <span class="kn">import</span> <span class="n">defaults</span>
<span class="kn">from</span> <span class="nn">ase.data</span> <span class="kn">import</span> <span class="n">atomic_numbers</span><span class="p">,</span> <span class="n">atomic_names</span><span class="p">,</span> <span class="n">atomic_masses</span><span class="p">,</span> <span class="n">covalent_radii</span><span class="p">,</span> <span class="n">chemical_symbols</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1">#get_potcar([&#39;opt/POSstart&#39;,&#39;opt/POSend&#39;])</span>
    <span class="c1">#bind_type,atom_b_conn_symb=get_site(&#39;opt/POSend&#39;,[&#39;NH2&#39;,&#39;N&#39;])</span>
    <span class="c1">#Sub_repeat(&#39;opt/descriptor-all&#39;)</span>
    <span class="c1">#poscar=&#39;./opt/CONTCAR-Ag111&#39;</span>
    <span class="c1">#dis_symb_matrix,dis_matrix=get_distance_adatoms(poscar,tol=0.1)</span>
    <span class="c1">#print(dis_symb_matrix,dis_matrix)</span>
    <span class="c1">#poscar=&#39;CONTCAR&#39;</span>
    <span class="c1">#adatoms,adatoms_symb,surfatoms,surfatoms_symb,subsurfatoms,subsurfatoms_symb=distinguish_atom_binding(poscar,tol=0.05)</span>
    <span class="c1">#print(adatoms,adatoms_symb,surfatoms,surfatoms_symb,subsurfatoms,subsurfatoms_symb)</span>
    <span class="c1">#bind_adatoms,bind_adatoms_symb,adspecie,bind_type_symb,bind_surfatoms,bind_surfatoms_symb=get_binding_adatom(poscar)</span>
    <span class="c1">#print(bind_adatoms,bind_adatoms_symb,adspecie,bind_type_symb,bind_surfatoms,bind_surfatoms_symb)</span>
    <span class="c1">#print(get_symmetry_surfatoms(poscar,tol=0.2))</span>
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">   Efile=&#39;ads_final_b1&#39; </span>
<span class="sd">   spec_ads,spec_ads_stable,dir_list_final, spec_ads_stable_surfa=get_site_stable(Efile,Ecut=-0.1)</span>
<span class="sd">   #print(spec_ads)</span>
<span class="sd">   print(spec_ads_stable, spec_ads_stable_surfa)</span>
<span class="sd">   #print(dir_list_final)</span>
<span class="sd">   &#39;&#39;&#39;</span>
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">   poscar=&#39;CONTCAR&#39;</span>
<span class="sd">   atom = atomic_numbers[&#39;N&#39;]</span>
<span class="sd">   atom_index,atom_neighs=get_atom_neigh(poscar,atom)</span>
<span class="sd">   print(atom_index,atom_neighs)</span>
<span class="sd">   &#39;&#39;&#39;</span>

    <span class="c1">#poscar=&#39;Pt_Au_100_b1_N_3/CONTCAR&#39;</span>
    <span class="c1">#bind_adatoms,bind_adatoms_symb,adspecie,bind_type_symb,bind_surfatoms,bind_surfatoms_sym = get_binding_adatom(poscar)</span>
    <span class="c1">#print(bind_adatoms,bind_adatoms_symb,adspecie,bind_type_symb,bind_surfatoms,bind_surfatoms_sym)</span>
    <span class="c1">#dis_symb_matrix,dis_matrix=get_distance_adatoms(&#39;opt/CONTCAR1&#39;)</span>
    <span class="c1">#print(dis_symb_matrix,dis_matrix)</span>
    <span class="c1">#adatoms,adatoms_symb,surfatoms,surfatoms_symb,subsurfatoms,subsurfatoms_symb=distinguish_atom_binding(poscar,tol_layer=0.01,tol=0.02,base_layer=4,atoms_layer=9)</span>
    <span class="c1">#print( adatoms,adatoms_symb,surfatoms,surfatoms_symb,subsurfatoms,subsurfatoms_symb)</span>

    <span class="c1">#atoms=[&#39;Au&#39;,&#39;Ag&#39;,&#39;Pt&#39;,&#39;Pd&#39;,&#39;Rh&#39;,&#39;Ru&#39;,&#39;Ir&#39;,&#39;Cu&#39;,&#39;N&#39;,&#39;O&#39;,&#39;H&#39;,&#39;Zn&#39;,&#39;Fe&#39;,&#39;Co&#39;,&#39;Ni&#39;]</span>
    <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">&#39;Os&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;Cu&#39;</span><span class="p">,</span> <span class="s1">&#39;Zn&#39;</span><span class="p">,</span> <span class="s1">&#39;Al&#39;</span><span class="p">,</span> <span class="s1">&#39;Sc&#39;</span><span class="p">,</span> <span class="s1">&#39;Ti&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;Cr&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="s1">&#39;Zr&#39;</span><span class="p">,</span> <span class="s1">&#39;Nb&#39;</span><span class="p">,</span> <span class="s1">&#39;Mo&#39;</span><span class="p">,</span> <span class="s1">&#39;Tc&#39;</span><span class="p">,</span> <span class="s1">&#39;Hf&#39;</span><span class="p">,</span> <span class="s1">&#39;Ta&#39;</span><span class="p">,</span>
        <span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;Re&#39;</span>
    <span class="p">]</span>
    <span class="n">names_atom</span><span class="p">,</span> <span class="n">radii_atoms</span><span class="p">,</span> <span class="n">mass_atoms</span><span class="p">,</span> <span class="n">vdw_radii_atoms</span> <span class="o">=</span> <span class="n">Extract_atomic_info</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">atoms</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">radii_atoms</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">vdw_radii_atoms</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">   layer_adatoms,layer_adatoms_symb=distinguish_atom_binding(&#39;opt/CONTCAR&#39;, tol=0.05,layer=&#39;adatom&#39;)</span>
<span class="sd">   print(&quot;adatom:%s%s&quot; %(layer_adatoms,layer_adatoms_symb))</span>
<span class="sd">   layer_surfatoms,layer_surfatoms_symb=distinguish_atom_binding(&#39;opt/CONTCAR&#39;, tol=0.05,layer=&#39;surf_atom&#39;)</span>
<span class="sd">   print(&quot;surf_atom:%s%s&quot; %(layer_surfatoms,layer_surfatoms_symb)) </span>
<span class="sd">   #print(&quot;surf_atom:%s&quot; %(layer_surfatoms_symb))</span>
<span class="sd">   layer_subsurfatoms,layer_subsurfatoms_symb=distinguish_atom_binding(&#39;opt/CONTCAR&#39;, tol=0.05,layer=&#39;subsurf_atom&#39;)</span>
<span class="sd">   print(&quot;subsurf_atom:%s%s&quot; %(layer_subsurfatoms,layer_subsurfatoms_symb))</span>
<span class="sd">   &#39;&#39;&#39;</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">   #radii = defaults.get(&#39;radii&#39;)</span>
<span class="sd">   #radii_adatom=[radii[i.numbers] for i in layer_atoms_symb]</span>
<span class="sd">   #number_adatom=[atomic_numbers[i] for i in layer_atoms_symb]</span>
<span class="sd">   radii_adatom=[covalent_radii[i] for i in number_adatom]</span>
<span class="sd">   radii_mean = np.mean(radii_adatom)</span>
<span class="sd">   print(radii_mean)</span>
<span class="sd">   &#39;&#39;&#39;</span>
    <span class="sd">&#39;&#39;&#39; </span>
<span class="sd">   adatoms,adatoms_symb,surfatoms,surfatoms_symb,subsurfatoms,subsurfatoms_symb=distinguish_atom_binding(&#39;opt/CONTCAR-N&#39;,tol=0.01)  </span>
<span class="sd">   print(&quot;adatom:%s%s&quot; %(adatoms,adatoms_symb))</span>
<span class="sd">   print(&quot;surf_atom:%s%s&quot; %(surfatoms,surfatoms_symb))</span>
<span class="sd">   bind_adatoms,bind_adatoms_symb,adspecie,bind_type_symb,bind_surfatoms,bind_surfatoms_sym = get_binding_adatom(&#39;opt/CONTCAR-N&#39;)</span>
<span class="sd">   print(bind_adatoms,bind_adatoms_symb,adspecie,bind_type_symb,bind_surfatoms,bind_surfatoms_sym)</span>
<span class="sd">   &#39;&#39;&#39;</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">   descriptor=[]</span>
<span class="sd">   #feature=[&#39;Enegativity&#39;,&#39;Valence_electron&#39;,&#39;Atomic_radius&#39;,&#39;Atomic_mass&#39;]</span>
<span class="sd">   feature=[&#39;Valence_electron&#39;,&#39;Atomic_radius&#39;]</span>
<span class="sd">   feature_value_surf=Construct_descriptor_info(&#39;Info/Element_Info&#39;,layer_surfatoms_symb,feature)</span>
<span class="sd">   feature_value_subsurf=Construct_descriptor_info(&#39;Info/Element_Info&#39;,layer_subsurfatoms_symb,feature)</span>
<span class="sd">   feature_value=np.hstack((feature_value_surf,feature_value_subsurf))</span>
<span class="sd">   print(feature_value)</span>
<span class="sd">   descriptor += [np.around(np.mean(feature_value,0),2)]</span>
<span class="sd">   print(descriptor)</span>
<span class="sd">   &#39;&#39;&#39;</span>
    <span class="c1">#bind_adatoms,bind_adatoms_symb,bind_type_symb,adspecie,bind_surfatoms,bind_surfatoms_symb=get_binding_adatom(&#39;opt/POSend&#39;)</span>
    <span class="c1">#print(bind_adatoms,bind_adatoms_symb,bind_type_symb,adspecie,bind_surfatoms,bind_surfatoms_symb)</span>

    <span class="c1">#bind_type,atom_b_conn_symb=get_site(&#39;opt/CONTCAR&#39;,[&#39;NH2&#39;,&#39;N&#39;])</span>
    <span class="c1">#print(bind_type)</span>

    <span class="c1">#dis_symb_matrix,dis_matrix=get_distance_adatoms(&#39;opt/CONTCAR&#39;)</span>
    <span class="c1">#print(dis_symb_matrix,dis_matrix)</span>
    <span class="c1">#s=&#39;opt/CONTCAR&#39;</span>
    <span class="c1">#if isinstance(s, str):</span>
    <span class="c1">#print(&quot;string&quot;)</span>
    <span class="c1">#else:</span>
    <span class="c1">#print(&quot;not string&quot;)</span>
    <span class="c1">#Sub_repeat(&#39;opt/descriptor-all&#39;)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Jiaqiang Yang; Feifeng Wu; Bin Shan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>